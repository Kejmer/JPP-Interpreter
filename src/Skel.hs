-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Types

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Types.Ident -> Result
transIdent x = case x of
  Types.Ident string -> failure x

transProgram :: Types.Program -> Result
transProgram x = case x of
  Types.MyProgram stmts -> failure x

transBlock :: Types.Block -> Result
transBlock x = case x of
  Types.Blok stmts -> failure x

transHBlock :: Types.HBlock -> Result
transHBlock x = case x of
  Types.AsProc pblock -> failure x
  Types.AsStmt stmt -> failure x

transStmt :: Types.Stmt -> Result
transStmt x = case x of
  Types.BStmt block -> failure x
  Types.DeclConst basictype ident expr -> failure x
  Types.DeclMut basictype ident expr -> failure x
  Types.Ass ident expr -> failure x
  Types.ArrAss ident expr1 expr2 -> failure x
  Types.Ret expr -> failure x
  Types.If expr hblock -> failure x
  Types.IfElse expr hblock1 hblock2 -> failure x
  Types.While expr hblock -> failure x
  Types.Print expr -> failure x
  Types.For expr proc_ -> failure x
  Types.SExp expr -> failure x
  Types.FDef basictype ident args pblock -> failure x
  Types.FDefAlt basictype ident args lambda -> failure x

transType :: Types.Type -> Result
transType x = case x of
  Types.Ref basictype -> failure x
  Types.MutRef basictype -> failure x
  Types.Mut basictype -> failure x
  Types.Const basictype -> failure x

transBasicType :: Types.BasicType -> Result
transBasicType x = case x of
  Types.Arr basictype -> failure x
  Types.Int -> failure x
  Types.Str -> failure x
  Types.Bool -> failure x
  Types.Void -> failure x
  Types.Fun basictype types -> failure x
  Types.TProc basictype args types -> failure x

transProc :: Types.Proc -> Result
transProc x = case x of
  Types.PDec args1 args2 block -> failure x

transLambda :: Types.Lambda -> Result
transLambda x = case x of
  Types.LDec basictype args block -> failure x

transPBlock :: Types.PBlock -> Result
transPBlock x = case x of
  Types.FProc proc_ -> failure x
  Types.FBlok block -> failure x
  Types.FVar ident -> failure x

transArg :: Types.Arg -> Result
transArg x = case x of
  Types.FArg type_ ident -> failure x

transExpr :: Types.Expr -> Result
transExpr x = case x of
  Types.EVar ident -> failure x
  Types.EInt integer -> failure x
  Types.ETrue -> failure x
  Types.EFalse -> failure x
  Types.EString string -> failure x
  Types.EParen expr -> failure x
  Types.EProc proc_ -> failure x
  Types.ELamb lambda -> failure x
  Types.ECall expr exprs -> failure x
  Types.EStringify expr -> failure x
  Types.EArr exprs -> failure x
  Types.EArrRead ident expr -> failure x
  Types.Neg expr -> failure x
  Types.Not expr -> failure x
  Types.EMul expr1 mulop expr2 -> failure x
  Types.EAdd expr1 addop expr2 -> failure x
  Types.EComp expr1 compop expr2 -> failure x
  Types.EAnd expr1 expr2 -> failure x
  Types.EOr expr1 expr2 -> failure x

transAddOp :: Types.AddOp -> Result
transAddOp x = case x of
  Types.Plus -> failure x
  Types.Minus -> failure x

transMulOp :: Types.MulOp -> Result
transMulOp x = case x of
  Types.Times -> failure x
  Types.Div -> failure x
  Types.Mod -> failure x

transCompOp :: Types.CompOp -> Result
transCompOp x = case x of
  Types.Low -> failure x
  Types.Grt -> failure x
  Types.LowEq -> failure x
  Types.GrtEq -> failure x
  Types.Eq -> failure x
  Types.NEq -> failure x
